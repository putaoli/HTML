JavaScript快速入门
Javascript代码可以直接写在网页任何地方
二种方式
1.由<script></script>包含代码就是JavaScript代码
2。把JavaScript代码单独的.js文件，然后在html中通过<script src="..."><script>
需要建设一个web服务器，然后以http：//开头的地址来正常执行所有Javascript
Javascript每个语句以；结束，语句块用{...}。但是Javascript并不强制哟啊求在每个语句的结尾加；游览器中负责执行JavaScript代码的引擎会自动在每个语句结尾补上；
不建议一行多个语句
{...}内的语句具有缩进，通常是4个空格。有助于我们理解代码的层次，所以编写代码时要遵守缩进规则
JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。所以可以把部分代码抽出来，作为函数来调用。这样可以减少代码的复杂度

注释二种
//开头到行末的字符被视为行注释
/*...*/是块注释把多行字符包裹起来，把一大块视为一个注释

JavaScript严格区分大小写

JavaScript数据类型
Number
123; // 整数123
0.456; // 浮点数0.456
1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5
-99; // 负数
NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示
Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity
JavaScript不区分整数和浮点数，统一用Number表示。Number可以做四则运算，规则跟数学一样。%是求余运算

字符串
字符串是以单引号或双引号括起来的任意文本，单引号和双引号只是一种表示方式，不是字符串的一部分

布尔值
布尔值和布尔代数的表示完成一致，一个布尔值只有true和false两种值，要么是true要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来：
true; // 这是一个true值
false; // 这是一个false值
2 > 1; // 这是一个true值
2 >= 3; // 这是一个false值
&&：与运算，只有所有都为true&&运算才是true
||：或运算，只要其中一个为true||运算就是true
！：非运算，它是一个单目运算符，把true变成false，把false变成true
布尔值经常出现在条件判断中
比较运算符：Javascript允许对任意数据类型做比较
要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符
1.==比较，它会自动转换数据类型再比较。很多时候，会的到非常诡异的结果
2.===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较
由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较
另一个例外时NaN这个特殊的Numbeer与所有其他值都不相等，包括再自己，唯一能判断NaN的方法时通过isNaN（）函数
isNaN(NaN); // true
最后要注意浮点数的相等比较
1 / 3 === (1 - 2 / 3); // false
这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true

null和undefined
null表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。

在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。

JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。

数组
数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：

[1, 2, 3.14, 'Hello', null, true];
上述数组包含6个元素。数组用[]表示，元素之间用,分隔。

另一种创建数组的方法是通过Array()函数实现：

new Array(1, 2, 3); // 创建了数组[1, 2, 3]
然而，出于代码的可读性考虑，强烈建议直接使用[]。

数组的元素可以通过索引来访问。请注意，索引的起始值为0：

var arr = [1, 2, 3.14, 'Hello', null, true];
arr[0]; // 返回索引为0的元素，即1
arr[5]; // 返回索引为5的元素，即true
arr[6]; // 索引超出了范围，返回undefined
对象
JavaScript的对象时一组由键-值组成的无序集合列如：
var person={
	name：'Bob'，
	age：20，
	tegs：['js','web','mobile'],
	city:'Beijing',
	hasCar:true,
	zipcode:null
}
JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了六个键值对，其中每个键又称为对象的属性，列如，person的name属性为’Bob‘
要获得一个对象的属性，我们要用对象变量，属性名的方式：
person.name//Bob

变量的基本概念上和初中的方程变量是一致的，只是再计算机程序中，变量不仅可以是数字，还可以是任意数据类型
变量再Javascript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合。且不能是数字开头，变量名也不能是关键字，如if，while等，申明一个变量用var语句
请不要用中文
使用等号对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var声明一次
这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言再定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。列如Java就是静态语言
请不要把赋值语句的等号等同于数字的等号，

strict模式
JavaScript再设计之初，为了方便初学者学习，不强制要求用var申明变量。这个错误的设计带来了严重的后果；如果一个变量没有通过var申明就被使用，那该变量就自动被申明为全局变量
再同一个页面的不同JavaScript文件中，如果不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调式错误结果
使用var申明的变量不是全局变量，它的范围被限制再该变量申明的函数体内，同时变量再不同的函数体内并不冲突
后来修改了这个设计缺陷，推出了strict模式，再strict模式下运行JavaScript代码，强制通过var申明变量，未使用var申明变量就使用，将导致运行错误
启用strict模式的方法是再JavaScript代码的第一行写上
'use strict'这是一个字符串，不支持strict模式的游览器会把它当作一个字符串语句执行，支持strict模式的游览器将开启strict模式运行

字符串
如果‘本身就是字符串那就用”“括起来。
如果字符串即包括’由包括”那就用转义字符串\来标识比如
‘I\'m\"ok\"!’
转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\
ASCII字符可以以\x##形式的十六进制表示
Unicode字符表示\u####
多行字符串
用反引号`...`表示（反引号再esc键下方）
`a
b
c`
模板字符串
要把多个字符串连接起来，可以用+号连接
如果很多变量需要连接用+号就比较麻烦，新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量
如：
var name='小明';
var age='20';
var message=`您好，${name},您今年${age}岁了！`;
alert(message);

操作字符串
获取字符串长度用函数length
获取字符串某个指定位置的字符，使用类型array的下标操作，索引号从0开始：
var s=’heel，world‘
s[0]；//'h'
特别注意字符串是不可变的如果字符串的某个索引赋值，不会由任何错误，但是，也没有任何效果

JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：
toUpperCase：把一个字符串全部变为大写
toLowerCase：把一个字符串全部变为小写
indexOf：会搜索指定字符串出现的位置（没有找到只当的子串，返回-1）
substring：返回指定索引区间的子串（
var s=’hello，world‘
s.substring（0，5）；（从索引0开始到5（不包括5））
s.substring（7）；（从索引7开始到结束）
）

数组
JavaScript的array可以包含任意数据类型，并通过索引方位每个元素
要取得array的长度，直接访问length属性
请注意，直接给Array的length赋一个新的值会导致Array大小的变化：
var arr = [1, 2, 3];
arr.length; // 3
arr.length = 6;
arr; // arr变为[1, 2, 3, undefined, undefined, undefined]
arr.length = 2;
arr; // arr变为[1, 2]
可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array：

var arr = ['A', 'B', 'C'];
arr[1] = 99;
arr; // arr现在变为['A', 99, 'C']

如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：

var arr = [1, 2, 3];
arr[5] = 'x';
arr; // arr变为[1, 2, 3, undefined, undefined, 'x']
大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript却不会有任何错误，再编写代码时，不建议直接修改array的大小，访问索引时要确保索引不会越界

indexOf与string类似，array也可以通过indexOf（）来搜索一个指定的元素的位置（返回索引，没找到返回-1）
slice就是对应string的substring版本，它截取array的部分元素，然后返回一个新的array
注意到slice()的起止参数包括开始索引，不包括结束索引。

如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：
var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
var aCopy = arr.slice();
aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
aCopy === arr; // false（地址不同所以不是完全相等）

push和pop
push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：
var arr = [1, 2];
arr.push('A', 'B'); // 返回Array新的长度: 4
arr; // [1, 2, 'A', 'B']
arr.pop(); // pop()返回'B'
arr; // [1, 2, 'A']
arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次
arr; // []
arr.pop(); // 空数组继续pop不会报错，而是返回undefined
arr; // []

unshift和shift
如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：
var arr = [1, 2];
arr.unshift('A', 'B'); // 返回Array新的长度: 4
arr; // ['A', 'B', 1, 2]
arr.shift(); // 'A'
arr; // ['B', 1, 2]
arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
arr; // []
arr.shift(); // 空数组继续shift不会报错，而是返回undefined
arr; // []

sort
sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：

reverse
把array元素反转
var arr = ['one', 'two', 'three'];
arr.reverse(); 
arr; // ['three', 'two', 'one']

splice方法是修改array的万能方法，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素
var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
// 从索引2开始删除3个元素,然后再添加两个元素:
arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
// 只删除,不添加:
arr.splice(2, 2); // ['Google', 'Facebook']
arr; // ['Microsoft', 'Apple', 'Oracle']
// 只添加,不删除:
arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']

concat
concat（）方法把当前的array和另一个array连接起来，并返回一个新的array
ar arr = ['A', 'B', 'C'];
var added = arr.concat([1, 2, 3]);
added; // ['A', 'B', 'C', 1, 2, 3]
arr; // ['A', 'B', 'C']
请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。

实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：

join
join方法是一个非常实用的方法，它把当前array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'
如果Array的元素不是字符串，将自动转换为字符串后再连接。

多维数组
var arr = [[1, 2, 3], [400, 500, 600], '-'];
上述Array包含3个元素，其中头两个元素本身也是Array。

对象
JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。
JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
}
JavaScript用一个{...}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。

上述对象申明了一个name属性，值是'小明'，birth属性，值是1990，以及其他一些属性。最后，把这个对象赋值给变量xiaoming后，就可以通过变量xiaoming来获取小明的属性了：
访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用''括起来
xiaohong的属性名middle-school不是一个有效的变量，就需要用''括起来。访问这个属性也无法使用.操作符，必须用['xxx']来访问：
实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型
如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined：
由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：
var xiaoming = {
    name: '小明'
};
xiaoming.age; // undefined
xiaoming.age = 18; // 新增一个age属性
xiaoming.age; // 18
delete xiaoming.age; // 删除age属性
xiaoming.age; // undefined
delete xiaoming['name']; // 删除name属性
xiaoming.name; // undefined
delete xiaoming.school; // 删除一个不存在的school属性也不会报错
如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：
var xiaoming = {
    name: '小明',
    birth: 1990,
    school: 'No.1 Middle School',
    height: 1.70,
    weight: 65,
    score: null
};
'name' in xiaoming; // true
'grade' in xiaoming; // false
不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：
因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。

要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：
var xiaoming = {
    name: '小明'
};
xiaoming.hasOwnProperty('name'); // true
xiaoming.hasOwnProperty('toString'); // false

JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true，因此上述代码条件判断的结果是true


for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来：

var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    console.log(key); // 'name', 'age', 'city'
}
要过滤掉对象继承的属性，用hasOwnProperty()来实现：
var o = {
    name: 'Jack',
    age: 20,
    city: 'Beijing'
};
for (var key in o) {
    if (o.hasOwnProperty(key)) {
        console.log(key); // 'name', 'age', 'city'
    }
}
由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引：
var a = ['A', 'B', 'C'];
for (var i in a) {
    console.log(i); // '0', '1', '2'
    console.log(a[i]); // 'A', 'B', 'C'
}
请注意，for ... in对Array的循环得到的是String而不是Number。
for循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。

while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：
do ... while
最后一种循环是do { ... } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：
循环是让计算机做重复任务的有效的方法，有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。JavaScript的死循环会让浏览器无法正常显示或执行当前页面的逻辑，有的浏览器会直接挂掉，有的浏览器会在一段时间后提示你强行终止JavaScript的执行，因此，要特别注意死循环的问题。

在编写循环代码时，务必小心编写初始条件和判断条件，尤其是边界值。特别注意i < 100和i <= 100是不同的判断逻辑。

但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。

为了解决这个问题，最新的ES6规范引入了新的数据类型Map。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：

Map是一组键值对

iterable
遍历array可以采用下标循环，遍历map和set就无法使用下标了。为了统一集合类型，引入了iterable类型，array，map，set都属于iterable类型
iterable类型的集合可以通过新的for。。。of循环来遍历
用for ... of循环遍历集合，用法如下：
var a = ['A', 'B', 'C'];
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
for (var x of a) { // 遍历Array
    console.log(x);
}
for (var x of s) { // 遍历Set
    console.log(x);
}
for (var x of m) { // 遍历Map
    console.log(x[0] + '=' + x[1]);
你可能会有疑问，for ... of循环和for ... in循环有何区别？

for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。

当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果：

var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x in a) {
    console.log(x); // '0', '1', '2', 'name'
}
for ... in循环将把name包括在内，但Array的length属性却不包括在内。

for ... of循环则完全修复了这些问题，它只循环集合本身的元素：
这就是为什么要引入新的for ... of循环。

然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例
Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：
var s = new Set(['A', 'B', 'C']);
s.forEach(function (element, sameElement, set) {
    console.log(element);
});
Map的回调函数参数依次为value、key和map本身：

var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
m.forEach(function (value, key, map) {
    console.log(value);
});

基本所有高级语言都有支持函数，Javascript函数可以像变量一样使用，具有强大的抽象能力

抽象
抽象是属数学中非常常见的概念。
借助抽象，我们可以不关心底层的具体计算过程，而直接在更高层上思考问题
写计算机程序也一样，函数就是最基本的与一种代码抽象方式

函数的定义
定义的方式如下：
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}
其中
function指出这是一个函数的定义
abs是函数名称
（x）括号内列出函数的参数，多个参数以，分隔
{...}之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句
函数体内，一旦执行到return时，函数就执行完毕，并将结果返回，因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑
如果没有reture语句，函数执行完毕也会返回结果，只是结果为underfined
由于js的函数也是一个对象，上述定义的abs（）函数实际上时一个函数对象，而函数名abs可以视为指向该函数的变量
因此，第二种定义函数的如下
var abs = function (x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
};
在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。

上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。

调用函数
调用函数时，按顺序传入参数即可
由于js允许传入任意个参数而不影响调用，因此传入的参数比定义参数多也没有问题。虽然函数内部并不需要这些参数
传入参数比定义的少也没有关系
abs（）；//nan
此时abs（x）函数的参数x将收到undefined，计算结果为NaN
要避免收到undefined，可以对参数进行检查
function abs(x) {
    if (typeof x !== 'number') {
        throw 'Not a number';
    }
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}

arguments
JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
利用arguments可以获得调用者传入的所有参数，也就是说，就是函数不定义任何参数，还是可以拿到参数的值
function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    var x = arguments[0];
    return x >= 0 ? x : -x;
}

abs(); // 0
abs(10); // 10
abs(-9); // 9
实际上，arguments最常用与判断传入参数的个数，
// foo(a[, b], c)
// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
function foo(a, b, c) {
    if (arguments.length === 2) {
        // 实际拿到的参数是a和b，c为undefined
        c = b; // 把b赋给c
        b = null; // b变为默认值
    }
    // ...
}
要把中间的参数变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值

rest参数
由于js函数允许接收任意个参数，于是我们就不得不用argument来好的参数
function foo(a, b) {
    var i, rest = [];
    if (arguments.length > 2) {
        for (i = 2; i<arguments.length; i++) {
            rest.push(arguments[i]);
        }
    }
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}
rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。

如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。

小心你的return语句
前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：
function foo() {
    return { // 这里不会自动加分号，因为{表示语句尚未结束
        name: 'foo'
    };
}

var申明的变量实际上是有作用域的。
如果一个变量在函数体内申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量
function foo() {
    var x = 1;
    x = x + 1;
}

x = x + 2; // ReferenceError! 无法在函数体外引用变量x

如果两个函数各自申明了一个变量，那么该变量只在各自的函数体内
